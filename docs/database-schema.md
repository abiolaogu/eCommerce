# Database Schema -- eCommerce Platform

## 1. Overview

FusionCommerce uses a database-per-service pattern where each microservice owns its schema and is the sole writer to its tables. The current implementation uses PostgreSQL accessed through the Knex query builder. The @fusioncommerce/database package provides a connection factory with configurable connection pooling.

## 2. Connection Configuration

```typescript
// packages/database/src/index.ts
export interface DatabaseConfig {
  connectionString: string;  // e.g., postgresql://user:password@host:5432/ecommerce
  poolMin?: number;          // Default: 2
  poolMax?: number;          // Default: 10
}
```

Each service connects independently using the `DATABASE_URL` environment variable:
```
DATABASE_URL=postgresql://user:password@dbaas-host:5432/ecommerce
```

Knex configuration from service knexfiles:
```typescript
const config: Knex.Config = {
  client: 'pg',
  connection: process.env.DATABASE_URL || 'postgresql://postgres:postgres@localhost:5432/ecommerce',
  migrations: {
    directory: './migrations',
    extension: 'ts'
  }
};
```

## 3. Orders Service Schema

### 3.1 Table: orders

Created by migration `20240101000000_create_orders_table.ts`:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | VARCHAR | PRIMARY KEY | UUID generated by crypto.randomUUID() |
| user_id | VARCHAR | NOT NULL | Customer identifier (mapped as customer_id in code) |
| product_id | VARCHAR | NOT NULL | Primary product reference |
| quantity | INTEGER | NOT NULL | Order quantity |
| total_price | DECIMAL(10,2) | NOT NULL | Calculated total (sum of item price * quantity) |
| currency | VARCHAR | NOT NULL | ISO currency code (USD, EUR, GBP, JPY) |
| status | VARCHAR | NOT NULL | Order lifecycle state: created, confirmed, failed |
| created_at | TIMESTAMP | NOT NULL | Order creation timestamp |

### 3.2 Multi-Tenancy Extension

Added by migration `20240102000000_add_multitenancy_to_orders.ts`:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| tenant_id | VARCHAR | NOT NULL, DEFAULT 'default' | Tenant isolation identifier |
| organization_id | VARCHAR | NULLABLE | B2B organization reference |
| purchase_order_number | VARCHAR | NULLABLE | B2B purchase order number |

**Indices**:
- `idx_orders_tenant_id` on (tenant_id)
- `idx_orders_organization_id` on (organization_id)

### 3.3 Runtime Repository Schema

The `PostgresOrderRepository` creates an alternative schema if the migration table does not exist:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | VARCHAR | PRIMARY KEY | UUID |
| customer_id | VARCHAR | NOT NULL | Customer identifier |
| items | JSONB | NOT NULL | Array of {sku, quantity, price} objects |
| total | DECIMAL(10,2) | NOT NULL | Computed order total |
| currency | VARCHAR | NOT NULL | ISO currency code |
| status | VARCHAR | NOT NULL | Order status |
| created_at | TIMESTAMP | DEFAULT now() | Creation timestamp |

**Note**: The migration schema and repository schema have structural differences. The migration uses `user_id` and `product_id` while the repository uses `customer_id` and JSONB `items`. This is a schema alignment gap that should be resolved.

## 4. Inventory Service Schema

### 4.1 Table: inventory

Created by migration `20240101000000_create_inventory_table.ts`:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| product_id | VARCHAR | PRIMARY KEY | SKU or product identifier |
| quantity | INTEGER | NOT NULL | Available stock count |
| version | INTEGER | NOT NULL, DEFAULT 0 | Optimistic locking version counter |

### 4.2 Multi-Tenancy Extension

Added by migration `20240102000000_add_multitenancy_to_inventory.ts`:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| tenant_id | VARCHAR | NOT NULL, DEFAULT 'default' | Tenant isolation identifier |

**Primary Key Change**: Composite primary key (product_id, tenant_id) replaces single-column (product_id).

**Index**: `idx_inventory_tenant_id` on (tenant_id)

### 4.3 Runtime Repository Schema

The `PostgresInventoryRepository` creates:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| sku | VARCHAR | PRIMARY KEY | Stock keeping unit identifier |
| quantity | INTEGER | NOT NULL | Available stock count |

**Reservation Logic** (optimistic locking via SQL):
```sql
UPDATE inventory
SET quantity = quantity - :requestedQuantity
WHERE sku = :sku AND quantity >= :requestedQuantity
```

## 5. Group Commerce Service Schema

### 5.1 Table: group_commerce_campaigns

Created by `PostgresGroupCommerceRepository.init()`:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | VARCHAR | PRIMARY KEY | Campaign UUID |
| product_id | VARCHAR | NOT NULL | Associated product identifier |
| min_participants | INTEGER | NOT NULL | Minimum participants for campaign success |
| max_participants | INTEGER | NOT NULL | Maximum allowed participants |
| actual_participants | INTEGER | NOT NULL | Current participant count |
| price | DECIMAL(10,2) | NOT NULL | Group buying discounted price |
| original_price | DECIMAL(10,2) | NOT NULL | Original product price |
| start_time | TIMESTAMP | NOT NULL | Campaign start datetime |
| end_time | TIMESTAMP | NOT NULL | Campaign end datetime |
| status | VARCHAR | NOT NULL | Campaign state: active, successful, failed, expired |

### 5.2 Migration Schema (from migration file)

The migration-based schema includes additional multitenancy columns (similar pattern to orders and inventory).

## 6. Catalog Service Schema

The Catalog Service currently uses only the `InMemoryCatalogRepository` with no PostgreSQL implementation or migration files. The in-memory data model is:

| Field | Type | Description |
|-------|------|-------------|
| id | string | UUID |
| sku | string | Stock keeping unit |
| name | string | Product name |
| description | string (optional) | Product description |
| price | number | Product price |
| currency | string | ISO currency code |
| inventory | number | Stock count |

**Recommendation**: Create a `PostgresCatalogRepository` with migration files following the pattern established by orders, inventory, and group-commerce services.

## 7. Payments Service Schema (Planned)

Based on the @fusioncommerce/contracts event types, the payments table should contain:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| payment_id | VARCHAR | PRIMARY KEY | Payment UUID |
| order_id | VARCHAR | NOT NULL, INDEX | Associated order reference |
| amount | DECIMAL(10,2) | NOT NULL | Payment amount |
| currency | VARCHAR(3) | NOT NULL | ISO currency code |
| status | VARCHAR | NOT NULL | pending, succeeded, failed |
| stripe_payment_intent_id | VARCHAR | NULLABLE | Stripe reference |
| failure_reason | TEXT | NULLABLE | Error description on failure |
| created_at | TIMESTAMP | DEFAULT now() | Creation timestamp |
| tenant_id | VARCHAR | NOT NULL, DEFAULT 'default' | Tenant isolation |

## 8. Shipping Service Schema (Planned)

Based on the @fusioncommerce/contracts event types:

| Column | Type | Constraints | Description |
|--------|------|-------------|-------------|
| id | VARCHAR | PRIMARY KEY | Shipment UUID |
| order_id | VARCHAR | NOT NULL, INDEX | Associated order reference |
| tracking_number | VARCHAR | NOT NULL | Carrier tracking number |
| carrier | VARCHAR | NOT NULL | Carrier name (FedEx, UPS, etc.) |
| label_url | TEXT | NOT NULL | Shipping label download URL |
| status | VARCHAR | NOT NULL | created, in_transit, delivered |
| created_at | TIMESTAMP | DEFAULT now() | Creation timestamp |
| tenant_id | VARCHAR | NOT NULL, DEFAULT 'default' | Tenant isolation |

## 9. Event Store (Kafka Topics as Data)

Kafka topics serve as an event store with configurable retention. The following topics are defined:

| Topic | Retention | Partitions (Recommended) | Key |
|-------|-----------|------------------------|-----|
| order.created | 7 days | 12 | orderId |
| inventory.reserved | 7 days | 12 | orderId |
| inventory.insufficient | 7 days | 6 | orderId |
| product.created | 30 days | 6 | productId |
| group-commerce.campaign.created | 30 days | 6 | campaignId |
| group-commerce.campaign.joined | 7 days | 6 | campaignId |
| group-commerce.campaign.successful | 30 days | 6 | campaignId |
| payment.created | 90 days | 12 | paymentId |
| payment.succeeded | 90 days | 12 | paymentId |
| payment.failed | 90 days | 12 | paymentId |
| shipping.label.created | 30 days | 6 | orderId |

## 10. Entity Relationship Diagram

```
+----------------+     +------------------+     +------------------+
|   products     |     |     orders       |     |   inventory      |
|----------------|     |------------------|     |------------------|
| id (PK)        |<----| items[].sku (FK) |---->| sku (PK)         |
| sku (UNIQUE)   |     | id (PK)          |     | quantity          |
| name           |     | customer_id      |     | version           |
| description    |     | items (JSONB)    |     | tenant_id         |
| price          |     | total            |     +------------------+
| currency       |     | currency         |
| inventory      |     | status           |     +------------------+
+----------------+     | created_at       |     | group_commerce   |
                       | tenant_id        |     | _campaigns       |
                       | organization_id  |     |------------------|
                       +--------+---------+     | id (PK)          |
                                |               | product_id       |
                       +--------v---------+     | min_participants |
                       |    payments      |     | max_participants |
                       |------------------|     | actual_part...   |
                       | payment_id (PK)  |     | price            |
                       | order_id (FK)    |     | original_price   |
                       | amount           |     | start_time       |
                       | currency         |     | end_time         |
                       | status           |     | status           |
                       +--------+---------+     +------------------+
                                |
                       +--------v---------+
                       |   shipments      |
                       |------------------|
                       | id (PK)          |
                       | order_id (FK)    |
                       | tracking_number  |
                       | carrier          |
                       | label_url        |
                       | status           |
                       +------------------+
```

## 11. Migration Strategy

### 11.1 Migration Naming Convention
```
YYYYMMDDHHMMSS_description.ts
```
Example: `20240101000000_create_orders_table.ts`

### 11.2 Migration Execution
```bash
npm run migrate --workspace @fusioncommerce/orders-service
# Runs: knex migrate:latest
```

### 11.3 Migration Best Practices
- Always check `hasTable()` before `createTable()` for idempotency
- Use `onConflict().merge()` for upsert operations
- Add indices for tenant_id columns used in WHERE clauses
- Use JSONB for flexible nested structures (e.g., order items)
- Decimal(10,2) for all monetary values

## 12. Data Access Patterns

| Pattern | Implementation | Service |
|---------|---------------|---------|
| Create/Read | INSERT + SELECT | Catalog, Group Commerce |
| Upsert | INSERT ... ON CONFLICT ... MERGE | Orders, Inventory |
| Optimistic Locking | UPDATE WHERE quantity >= :requested | Inventory reservation |
| JSONB Query | SELECT with JSON parsing in application | Orders (items field) |
| Composite Key | PRIMARY KEY (product_id, tenant_id) | Inventory (multi-tenant) |

---

*Document version: 1.0*
*Last updated: 2026-02-17*
*Product: FusionCommerce eCommerce Platform*
